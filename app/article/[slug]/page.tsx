import { notFound } from "next/navigation";
import { getAllPublishedArticles, getPublishedArticleBySlug } from "@/lib/articles";
import ArticleClient from "./ArticleClient";
import ArticleJsonLd from "./ArticleJsonLd";
import type { Metadata } from "next";

/**
 * Extract individual reference strings from raw markdown content.
 * Looks for content after the "## References" heading.
 * Handles both numbered references ("1. Author (Year). Title...")
 * and unnumbered references (plain text lines).
 */
function extractReferences(content: string): string[] {
  const lines = content.split(/\r?\n/);
  let inReferences = false;
  const refLines: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (/^#{1,3}\s+references/i.test(trimmed)) {
      inReferences = true;
      continue;
    }
    if (inReferences) {
      // Stop if we hit another heading
      if (/^#{1,3}\s+/.test(trimmed)) {
        break;
      }
      // Skip empty lines
      if (!trimmed) continue;
      // Numbered reference: strip the leading number prefix
      if (/^\d+\.\s+/.test(trimmed)) {
        refLines.push(trimmed.replace(/^\d+\.\s*/, ""));
      } else {
        // Unnumbered reference: accept any non-empty, non-heading line
        refLines.push(trimmed);
      }
    }
  }

  return refLines;
}

export const dynamicParams = true;
export const dynamic = "force-dynamic";

export async function generateStaticParams() {
  const articles = await getAllPublishedArticles();
  return articles.map((a) => ({ slug: a.slug }));
}

async function resolveArticle(slug: string) {
  try {
    return await getPublishedArticleBySlug(slug);
  } catch {
    return null;
  }
}

export async function generateMetadata({ params }: { params: { slug: string } }): Promise<Metadata> {
  const article = await resolveArticle(params.slug);
  if (!article) return {};

  const description = article.abstract
    ? article.abstract.slice(0, 160).trim()
    : article.content.slice(0, 160).replace(/[#*\n]+/g, " ").trim();

  const authors = article.authors && article.authors.length
    ? article.authors
    : [article.authorUsername];

  const publishedDate = article.publishedAt ?? article.createdAt;
  const citationDate = publishedDate
    ? `${publishedDate.getFullYear()}/${String(publishedDate.getMonth() + 1).padStart(2, "0")}/${String(publishedDate.getDate()).padStart(2, "0")}`
    : undefined;

  const references = extractReferences(article.content);

  return {
    title: article.title,
    description,
    alternates: {
      canonical: `https://americanimpactreview.com/article/${params.slug}`,
    },
    openGraph: {
      title: article.title,
      description,
      url: `https://americanimpactreview.com/article/${params.slug}`,
      siteName: "American Impact Review",
      locale: "en_US",
      type: "article",
      // og:image auto-generated by opengraph-image.tsx in this route
    },
    twitter: {
      card: "summary_large_image",
      title: article.title,
      description,
      // twitter:image auto-generated by opengraph-image.tsx in this route
    },
    other: {
      "citation_title": article.title,
      ...(citationDate ? { "citation_publication_date": citationDate } : {}),
      "citation_journal_title": "American Impact Review",
      "citation_journal_abbrev": "Am. Impact Rev.",
      "citation_volume": "1",
      "citation_issue": "1",
      "citation_firstpage": params.slug,
      "citation_lastpage": params.slug,
      ...(article.doi ? { "citation_doi": article.doi } : {}),
      "citation_language": "en",
      "citation_publisher": "Global Talent Foundation",
      "citation_article_type": "Research Article",
      "citation_pdf_url": (article as any).pdfUrl || `https://americanimpactreview.com/articles/${params.slug}.pdf`,
      "citation_fulltext_html_url": `https://americanimpactreview.com/article/${params.slug}`,
      "citation_abstract_html_url": `https://americanimpactreview.com/article/${params.slug}`,
      ...(article.abstract ? { "citation_abstract": article.abstract.replace(/\*\*/g, "") } : {}),
      ...(article.keywords?.length ? { "citation_keywords": article.keywords.join(", ") } : {}),
      ...(references.length ? { "citation_reference": references } : {}),
      "dc.identifier": article.doi || params.slug,
      "DC.title": article.title,
      "DC.date": citationDate || "",
      "DC.publisher": "Global Talent Foundation",
      "DC.type": "Text",
      "DC.format": "text/html",
      "DC.language": "en",
      "DCTERMS.isPartOf": "American Impact Review",
    },
  };
}

/**
 * Server component that renders citation_author + citation_author_institution
 * meta tags in the correct alternating order (PLOS ONE pattern).
 */
function ScholarAuthorMeta({ authors, affiliations, orcids }: { authors: string[]; affiliations: string[]; orcids: string[] }) {
  const tags: React.ReactNode[] = [];
  for (let i = 0; i < authors.length; i++) {
    tags.push(
      <meta key={`author-${i}`} name="citation_author" content={authors[i]} />
    );
    const affil = affiliations[i] || affiliations[affiliations.length - 1];
    if (affil) {
      tags.push(
        <meta key={`affil-${i}`} name="citation_author_institution" content={affil} />
      );
    }
    const orcid = orcids[i];
    if (orcid && /^\d{4}-\d{4}-\d{4}-\d{3}[\dX]$/.test(orcid)) {
      tags.push(
        <meta key={`orcid-${i}`} name="citation_author_orcid" content={`https://orcid.org/${orcid}`} />
      );
    }
    tags.push(
      <meta key={`dc-creator-${i}`} name="DC.creator" content={authors[i]} />
    );
  }
  return <>{tags}</>;
}

export default async function ArticlePage({ params }: { params: { slug: string } }) {
  const article = await resolveArticle(params.slug);
  if (!article) notFound();

  const authors = article.authors && article.authors.length
    ? article.authors
    : [article.authorUsername];
  const affiliations = article.affiliations ?? [];
  const orcids = article.orcids ?? [];

  const serialized = {
    ...article,
    publishedAt: article.publishedAt ? article.publishedAt.toISOString() : null,
    createdAt: article.createdAt ? article.createdAt.toISOString() : null,
    receivedAt: article.receivedAt ? article.receivedAt.toISOString() : null,
    acceptedAt: article.acceptedAt ? article.acceptedAt.toISOString() : null,
    viewCount: (article as any).viewCount ?? 0,
    manuscriptUrl: (article as { manuscriptUrl?: string }).manuscriptUrl || null,
  };

  const description = article.abstract
    ? article.abstract.slice(0, 300).trim()
    : article.content.slice(0, 300).replace(/[#*\n]+/g, " ").trim();

  return (
    <>
      <ArticleJsonLd
        title={article.title}
        authors={authors}
        orcids={orcids}
        publishedAt={article.publishedAt ? article.publishedAt.toISOString() : null}
        createdAt={article.createdAt ? article.createdAt.toISOString() : null}
        receivedAt={article.receivedAt ? article.receivedAt.toISOString() : null}
        acceptedAt={article.acceptedAt ? article.acceptedAt.toISOString() : null}
        description={description}
        slug={params.slug}
        imageUrl={article.imageUrl}
        doi={article.doi}
        keywords={article.keywords}
        openAccess={(article as any).openAccess}
        license={(article as any).license}
      />
      <ScholarAuthorMeta authors={authors} affiliations={affiliations} orcids={orcids} />
      <ArticleClient article={serialized} />
    </>
  );
}
